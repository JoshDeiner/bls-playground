import logging

from fastapi import HTTPException


def map_bls_data_with_ids(bls_response):
    # Extract data from the BLS response (simulate API response if needed)
    response = bls_response

    if not response:
        raise HTTPException(status_code=404,
                            detail="No response received from the API")

    logging.info(f"Response received from API")

    # Check if series and data exist
    if not response.get("Results") or not response["Results"].get("series"):
        raise HTTPException(
            status_code=400, detail="No valid series data found in the API response"
        )

    # Extract the series information
    series_data = response["Results"]["series"][0]
    series_entry = {
        "catalog_id": series_data.get("seriesID"),
        "catalog_title": series_data.get("catalog", {}).get("series_title"),
        "seasonality": series_data.get("catalog", {}).get("seasonality"),
        "survey_name": series_data.get("catalog", {}).get("survey_name"),
        "measure_data_type": series_data.get("catalog", {}).get("measure_data_type"),
        "area": series_data.get("catalog", {}).get("area"),
        "item": series_data.get("catalog", {}).get("item"),
    }

    # Initialize lists for series data and calculations
    series_data_entries = []
    calculations_entries = []

    # Extract the series data and calculations
    for idx, data_point in enumerate(series_data.get("data", [])):
        series_data_entry = {
            # You can let the database handle the ID instead of using idx+1 if
            # needed
            "series_id": idx + 1,  # Can be replaced if auto-generated by the DB
            "year": data_point.get("year"),
            "period": data_point.get("period"),
            "period_name": data_point.get("periodName"),
            "value": data_point.get("value"),
            "footnotes": data_point.get("footnotes", [{}]),
        }
        series_data_entries.append(series_data_entry)

        calculations_entry = {
            "series_data_id": idx
            + 1,
            # Corresponds to series_data ID (or use actual DB-assigned ID)
            "pct_changes": data_point.get("calculations", {}).get("pct_changes", {}),
            "net_changes": data_point.get("calculations", {}).get("net_changes", {}),
        }
        calculations_entries.append(calculations_entry)

    # Final result: mapping into key-value pairs
    result = {
        "series": series_entry,
        "series_data": series_data_entries,
        "calculations": calculations_entries,
    }

    return result
